#include "il2cpp-config.h"
#include "MetadataLoader.h"
#include "os/File.h"
#include "os/Mutex.h"
#include "utils/MemoryMappedFile.h"
#include "utils/PathUtils.h"
#include "utils/Runtime.h"
#include "utils/Logging.h"

#include <string.h>
#include <stdio.h>

#ifndef ENCRYPTION_AES_HPP_
#define ENCRYPTION_AES_HPP_

#include <stdint.h>
#include <string.h>
#include <iostream>
#ifndef __AVR__
#define IF_PROGMEM
#include <string>
#else
#define IF_PROGMEM PROGMEM
#include <avr/pgmspace.h>
#endif

class Aes {
public:
    Aes();
    ~Aes();

    int counter = 0;

#ifndef __AVR__
    /**** PC solution ****/
    // Functions below return streams of Bytes with additional cell for printing functions ('\0'),
    // but outputSize applies to real crypted/decrypted data in Bytes.
    uint8_t* CryptData(const char* data, size_t dataSize, const char* key, uint8_t* IV, size_t& outputSize);
    char* DecryptData(uint8_t* data, size_t dataSize, const char* key, uint8_t* IV, size_t& outputSize);
    void Stop();

    uint8_t* CryptData2(const char* data, size_t dataSize, const char* key, uint8_t* IV, size_t& outputSize);
    char* DecryptData2(uint8_t* data, size_t dataSize, const char* key, uint8_t* IV, size_t& outputSize);
private:
#endif

    /**** AVR solution ****/
    void Crypt(uint8_t* data, uint8_t* key, uint8_t* IV);
    void Decrypt(uint8_t* data, uint8_t* key, uint8_t* IV);

private:

    void Sanitize();

    void VecToBox(uint8_t(*arr)[4][4], uint8_t* data);
    void BoxToVec(uint8_t(*arr)[4][4], uint8_t* data);

    void GetFGVector(uint8_t(*arr)[4][4], uint8_t round, uint8_t* output);
    void ExpandKey(uint8_t(*keyBox)[4][4], uint8_t round);
    void RewindKey(uint8_t(*keyBox)[4][4], uint8_t round);
    void AddRoundKey(uint8_t(*text)[4][4], uint8_t(*curKeyBox)[4][4]);

    void Substitution(uint8_t(*text)[4][4], int mode);
    void ShiftRow(uint8_t(*arr)[4][4], int row, int mode);
    void ShiftRows(uint8_t(*text)[4][4], int mode);
    int MultiplyBy2(uint8_t value);
    void MixColumn(uint8_t(*text)[4][4], int mode);
    void CryptRound(uint8_t(*text)[4][4], uint8_t(*curKeyBox)[4][4], int curRound);
    void DecryptRound(uint8_t(*text)[4][4], uint8_t(*curKeyBox)[4][4], int curRound);

#ifndef __AVR__
    void CalculatePaddingData(const char* data, size_t dataSize, size_t& tailingSize, bool& newBlock);
    void AddPaddingData(uint8_t* chunk, uint8_t pValue, bool withNewBlock);
    size_t GetAlignedPadding(const char* data, size_t dataSize);
    size_t GetPaddingSize(char* data, size_t dataSize);
    void PrecomputeDecryptKey(uint8_t* key);

    bool stop;
    uint8_t expandedKey[4][4];
#endif

    uint8_t keyBox[4][4];
    uint8_t toCipherOrPlain[4][4];
    uint8_t tempBox[4][4];
    uint8_t fgVec[4];

};

#endif /* ENCRYPTION_AES_HPP_ */



const uint8_t sBOX[16][16] = {
        { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76 },
        { 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0 },
        { 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15 },
        { 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75 },
        { 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84 },
        { 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF },
        { 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8 },
        { 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2 },
        { 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73 },
        { 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB },
        { 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79 },
        { 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08 },
        { 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A },
        { 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E },
        { 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF },
        { 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 }
};

const uint8_t sInvBOX[16][16] = {
        { 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB },
        { 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB },
        { 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E },
        { 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25 },
        { 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92 },
        { 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84 },
        { 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06 },
        { 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B },
        { 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73 },
        { 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E },
        { 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B },
        { 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4 },
        { 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F },
        { 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF },
        { 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61 },
        { 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D }
};

const uint8_t fMat[4][4] = {
        { 0x02, 0x03, 0x01, 0x01 },
        { 0x01, 0x02, 0x03, 0x01 },
        { 0x01, 0x01, 0x02, 0x03 },
        { 0x03, 0x01, 0x01, 0x02 }
};

const uint8_t fInvMat[4][4] = {
        { 0x0E, 0x0B, 0x0D, 0x09 },
        { 0x09, 0x0E, 0x0B, 0x0D },
        { 0x0D, 0x09, 0x0E, 0x0B },
        { 0x0B, 0x0D, 0x09, 0x0E }
};

const uint8_t rCON[15] = {
        0x01, 0x02, 0x04, 0x08,
        0x10, 0x20, 0x40, 0x80,
        0x1B, 0x36, 0x6C, 0xD8,
        0xAB, 0xD4, 0x9A
};



Aes::Aes() {
    Sanitize();
}

Aes::~Aes() {
}

void Aes::Sanitize() {
    memset(keyBox, 0, 16);
    memset(toCipherOrPlain, 0, 16);
    memset(tempBox, 0, 16);
    memset(fgVec, 0, 4);
}

void Aes::VecToBox(uint8_t(*arr)[4][4], uint8_t * data) {
    for (int i = 0; i<4; i++) {
        for (int j = 0; j<4; j++) {
            (*arr)[j][i] = data[i * 4 + j];
        }
    }
}

void Aes::BoxToVec(uint8_t(*arr)[4][4], uint8_t * data) {
    for (int i = 0; i<4; i++) {
        for (int j = 0; j<4; j++) {
            data[i * 4 + j] = (*arr)[j][i];
        }
    }
}

void Aes::GetFGVector(uint8_t(*arr)[4][4], uint8_t round, uint8_t * output) {
    //Load data with shift
    for (int i = 0; i<4; i++) {
        output[i] = (*arr)[(i + 1) % 4][3];
        output[i] = sBOX[output[i] >> 4 & 0x0F][output[i] & 0x0F];
    }
    output[0] ^= rCON[round];
}

void Aes::ExpandKey(uint8_t(*keyBox)[4][4], uint8_t round) {

    memset(fgVec, 0, 4);
    GetFGVector(keyBox, round, fgVec);

    //W4
    for (int i = 0; i<4; i++) (*keyBox)[i][0] ^= fgVec[i];

    //W5 - W7
    for (int j = 0; j<3; j++) {
        for (int i = 0; i<4; i++) {
            (*keyBox)[i][j + 1] ^= (*keyBox)[i][j];
        }
    }

}

void Aes::RewindKey(uint8_t(*keyBox)[4][4], uint8_t round) {

    //W5 - W7
    for (int j = 3; j>0; j--) {
        for (int i = 0; i<4; i++) {
            (*keyBox)[i][j] ^= (*keyBox)[i][j - 1];
        }
    }

    memset(fgVec, 0, 4);
    GetFGVector(keyBox, round, fgVec);

    //W4
    for (int i = 0; i<4; i++) (*keyBox)[i][0] ^= fgVec[i];
}



void Aes::AddRoundKey(uint8_t(*text)[4][4], uint8_t(*curKeyBox)[4][4]) {
    for (int i = 0; i<4; i++) {
        for (int j = 0; j<4; j++) {
            (*text)[i][j] = (*text)[i][j] ^ (*curKeyBox)[i][j];
        }
    }
}

void Aes::Substitution(uint8_t(*text)[4][4], int mode) {

    const uint8_t(*subMat)[16];
    if (mode == 0) {
        subMat = sBOX;
    }
    else{
        subMat = sInvBOX;
    }

    for (int i = 0; i<4; i++) {
        for (int j = 0; j<4; j++) {
            (*text)[i][j] = subMat[(*text)[i][j] >> 4 & 0x0F][(*text)[i][j] & 0x0F];
        }
    }
}

void Aes::ShiftRow(uint8_t(*arr)[4][4], int row, int mode) {
    if (mode == 0) {
        for (int j = 0; j<row; j++) {
            uint8_t temp = (*arr)[row][0];
            for (int i = 0; i<4 - 1; i++) {
                (*arr)[row][i] = (*arr)[row][i + 1];
            }
            (*arr)[row][4 - 1] = temp;
        }
    }
    else {
        for (int j = 0; j<row; j++) {
            uint8_t temp = (*arr)[row][3];
            for (int i = 3; i>0; i--) {
                (*arr)[row][i] = (*arr)[row][i - 1];
            }
            (*arr)[row][0] = temp;
        }
    }
}

void Aes::ShiftRows(uint8_t(*text)[4][4], int mode) {
    ShiftRow(text, 1, mode);
    ShiftRow(text, 2, mode);
    ShiftRow(text, 3, mode);
}

int Aes::MultiplyBy2(uint8_t value) {
    int ret = value << 1;
    if ((1 << 7) & value) {
        ret ^= 0b00011011;
    }
    return ret;
}

void Aes::MixColumn(uint8_t(*text)[4][4], int mode) {

    const uint8_t(*subMat)[4];
    if (mode == 0) {
        subMat = fMat;
    }
    else{
        subMat = fInvMat;
    }

    memset(tempBox, 0, 16);

    for (int z = 0; z<4; z++) {
        for (int j = 0; j<4; j++) {
            for (int i = 0; i<4; i++) {

                if (subMat[z][i] == 0x01) {																					//x1
                    tempBox[z][j] ^= (*text)[i][j];
                }
                else if (subMat[z][i] == 0x02) {
                    tempBox[z][j] ^= MultiplyBy2((*text)[i][j]);																//x2
                }
                else if (subMat[z][i] == 0x03) {
                    tempBox[z][j] ^= MultiplyBy2((*text)[i][j]) ^ (*text)[i][j];												//x3
                }
                else if (subMat[z][i] == 0x09) {
                    tempBox[z][j] ^= MultiplyBy2(MultiplyBy2(MultiplyBy2((*text)[i][j]))) ^ (*text)[i][j];						//x9
                }
                else if (subMat[z][i] == 0x0B) {
                    tempBox[z][j] ^= MultiplyBy2(MultiplyBy2(MultiplyBy2((*text)[i][j])) ^ (*text)[i][j]) ^ (*text)[i][j];		//x11
                }
                else if (subMat[z][i] == 0x0D) {
                    tempBox[z][j] ^= MultiplyBy2(MultiplyBy2(MultiplyBy2((*text)[i][j]) ^ (*text)[i][j])) ^ (*text)[i][j];		//x13
                }
                else if (subMat[z][i] == 0x0E) {
                    tempBox[z][j] ^= MultiplyBy2(MultiplyBy2(MultiplyBy2((*text)[i][j]) ^ (*text)[i][j]) ^ (*text)[i][j]);		//x14
                }

            }
        }
    }


    //Copy buffer to text array
    for (int j = 0; j<4; j++) {
        for (int i = 0; i<4; i++) {
            (*text)[j][i] = tempBox[j][i];
        }
    }
}

void Aes::CryptRound(uint8_t(*text)[4][4], uint8_t(*curKeyBox)[4][4], int curRound) {
    if (curRound == 0) { AddRoundKey(text, curKeyBox); return; }
    Substitution(text, 0);
    ShiftRows(text, 0);
    if (curRound != 10) MixColumn(text, 0);
    AddRoundKey(text, curKeyBox);
}

void Aes::DecryptRound(uint8_t(*text)[4][4], uint8_t(*curKeyBox)[4][4], int curRound) {
    AddRoundKey(text, curKeyBox);
    if (curRound == 0) return;
    if (curRound != 10) MixColumn(text, 1);
    ShiftRows(text, 1);
    Substitution(text, 1);
}

void Aes::Crypt(uint8_t * data, uint8_t * key, uint8_t * IV) {

    if (IV != 0) {
        for (int i = 0; i<16; i++) {
            data[i] ^= IV[i];
        }
    }

    VecToBox(&keyBox, key);
    VecToBox(&toCipherOrPlain, data);

    //Init Round
    CryptRound(&toCipherOrPlain, &keyBox, 0);


    for (int i = 0; i<10; i++) { //should be 10
        //Round 1
        ExpandKey(&keyBox, i);
        CryptRound(&toCipherOrPlain, &keyBox, i + 1);
    }

    //Copy data
    BoxToVec(&toCipherOrPlain, data);
}

void Aes::Decrypt(uint8_t * data, uint8_t * key, uint8_t * IV) {

    VecToBox(&toCipherOrPlain, data);

    //Init Round
#ifndef __AVR__
    memcpy(keyBox, expandedKey, 16);
#else
    VecToBox(&keyBox, key);
	for (int i = 0; i<10; i++) {
		ExpandKey(&keyBox, i);
	}
#endif

    DecryptRound(&toCipherOrPlain, &keyBox, 10);

    for (int i = 9; i>-1; i--) {
        RewindKey(&keyBox, i);
        DecryptRound(&toCipherOrPlain, &keyBox, i);
    }

    BoxToVec(&toCipherOrPlain, data);

    if (IV != 0) {
        for (int i = 0; i<16; i++) {
            data[i] ^= IV[i];
        }
    }
}


#ifndef __AVR__

void Aes::PrecomputeDecryptKey(uint8_t * key) {
    VecToBox(&expandedKey, key);
    for (int i = 0; i<10; i++) {
        ExpandKey(&expandedKey, i);
    }
}


void Aes::CalculatePaddingData(const char * data, size_t dataSize, size_t & tailingSize, bool & newBlock) {
    //Calculate tailing size
    if (dataSize < 16) {
        tailingSize = dataSize;
    }
    else {
        tailingSize = dataSize % 16;
    }
    //Check if we need padding and last bytes are the same
    if ((tailingSize > 1 && data[dataSize - 1] == data[dataSize - 2]) || tailingSize == 15) {
        newBlock = true;
    }
    if (tailingSize == 0 && dataSize >= 16 && data[dataSize - 1] == data[dataSize - 2]) {
        newBlock = true;
    }
}

void Aes::AddPaddingData(uint8_t * chunk, uint8_t tailingSize, bool withNewBlock) {
    uint8_t pValue = 16 - tailingSize;
    if (withNewBlock == false && tailingSize != 0) {
        memset(&chunk[tailingSize], pValue, pValue);
    }
    else {
        memset(&chunk[0], pValue, 16);
    }
}

size_t Aes::GetAlignedPadding(const char * data, size_t dataSize) {
    char c = data[dataSize - 1];
    size_t counter = 0;
    for (int i = 0; i<16; i++) {
        if (data[dataSize - 1 - i] != c) break;
        ++counter;
    }
    return counter;
}

void Aes::Stop() {
    stop = false;
}

uint8_t * Aes::CryptData(const char * data, size_t dataSize, const char * key, uint8_t * IV, size_t & outputSize) {
    if (data == nullptr || dataSize == 0) return nullptr;
    //Setup
    Sanitize();
    uint8_t uToCrypt[16];
    uint8_t uKey[16];
    uint8_t temp[16];
    memset(temp, 0, 16);
    memset(uToCrypt, 0, 16);
    memset(uKey, 0, 16);
    memcpy(uKey, (uint8_t*)key, 16);
    bool newBlock = false;
    size_t tailingSize = 0;
    stop = false;

    //Initialize important variables & Memmory allocation
    CalculatePaddingData(data, dataSize, tailingSize, newBlock);
    outputSize = ((dataSize + 16) / 16) * 16 + newBlock * 16;
    if (tailingSize == 0) outputSize -= 16;
    uint8_t * output = new uint8_t[outputSize + 1];
    if (IV != nullptr) memcpy(temp, IV, 16);

    counter = 0;
    //CBC chain crypt;
    for (size_t pos = 0; pos<outputSize; pos += 16) {
        counter += 16;
        //Prepare data
        if (((int)dataSize - (int)pos) < 16) {
            //Add padding
            memcpy(uToCrypt, (uint8_t*)&data[dataSize - tailingSize], tailingSize);
            if (newBlock == false) {
                AddPaddingData(uToCrypt, tailingSize, newBlock);
            }
            else {
                if (pos != outputSize - 16) {
                    AddPaddingData(uToCrypt, tailingSize, false);
                }
                else {
                    if (tailingSize != 0) {
                        AddPaddingData(uToCrypt, tailingSize, newBlock);
                    }
                    else {
                        memset(uToCrypt, GetAlignedPadding(data, dataSize), 16);
                    }
                }
            }
        }
        else {
            if (newBlock == false) {
                memcpy(uToCrypt, (uint8_t*)&data[pos], 16);
            }
            else {
                if (pos + 16 == outputSize) {
                    memset(uToCrypt, 0, 16);
                }
                else {
                    memcpy(uToCrypt, (uint8_t*)&data[pos], 16);
                }
            }
        }

        //Crypt
        Sanitize();
        Crypt(uToCrypt, uKey, temp);
        memcpy(temp, uToCrypt, 16);

        //Copy data
        memcpy(&output[pos], uToCrypt, 16);
    }

    //Fix output for printing functions
    output[outputSize] = 0;

    return output;
}

size_t Aes::GetPaddingSize(char * data, size_t dataSize) {
    bool ifAdditionalBlock = true;
    char c = data[dataSize - 1];

    for (int i = 0; i<15; i++) {
        if (c != data[dataSize - 1 - 15 + i]) {
            ifAdditionalBlock = false;
            break;
        }
    }

    //Case 4: repeating data on the end but aligned to 16B
    if (ifAdditionalBlock == true && c == 0x00) {
        return 16;
    }

    //Case 3: new block because of repeating data on stream end (padded 2 blocks)
    if (ifAdditionalBlock == true) {
        int counter = 0;
        for (int i = 0; i<(int)c; i++) {
            if (data[dataSize - 1 - 16 - i] == c) {
                ++counter;
            }
            else {
                break;
            }
        }
        if (counter == (int)c) {
            return (size_t)(c + 16);
        }
    }

    //Case 2: new block but no padding in previous block (padded only last)
    if (ifAdditionalBlock == true) {
        int counter = 0;
        for (int i = 0; i<(int)c; i++) {
            if (data[dataSize - 1 - 16 - i] == data[dataSize - 1 - 16]) {
                ++counter;
            }
            else {
                break;
            }
        }
        if (counter == (int)c) {
            return 16;
        }
    }

    //Case 1: no new block (no repeating data on end)
    int counter = 0;
    if (ifAdditionalBlock == false) {
        for (int i = 0; i<(int)c; i++) {
            if (data[dataSize - 1 - i] == c) {
                ++counter;
            }
            else {
                break;
            }
        }
    }
    if (counter == (int)c) {
        return (size_t)c;
    }

    //Case 0: Data perfectly 16B aligned - no padding
    return 0;
}


char * Aes::DecryptData(uint8_t * data, size_t dataSize, const char * key, uint8_t * IV, size_t & outputSize) {
    if (data == nullptr || dataSize == 0) return nullptr;
    //Setup
    Sanitize();
    uint8_t uToDecrypt[16];
    uint8_t uKey[16];
    uint8_t temp[16];
    memset(temp, 0, 16);
    memset(uToDecrypt, 0, 16);
    memset(uKey, 0, 16);
    memcpy(uKey, (uint8_t*)key, 16);
    stop = false;

    //Memmory allocation
    outputSize = dataSize;
    char * output = new char[outputSize + 1];
    if (IV != nullptr) memcpy(temp, IV, 16);

    //Precompute key
    memset(expandedKey, 0, 16);
    PrecomputeDecryptKey((uint8_t*)key);

    counter = 0;

    //CBC chain Decrypt;
    for (size_t pos = 0; pos<outputSize; pos += 16) {
        counter += 16;
        if (stop == true) break;

        //Prepare data
        memcpy(uToDecrypt, (uint8_t*)&data[pos], 16);

        //Decrypt
        Sanitize();
        Decrypt(uToDecrypt, uKey, temp);
        memcpy(temp, (uint8_t*)&data[pos], 16);

        //Copy data
        memcpy(&output[pos], uToDecrypt, 16);
    }

    //Remove padding
    size_t padding = GetPaddingSize(output, outputSize);
    if (padding != 0) {
        memset(&output[outputSize - padding], 0, padding);
        outputSize -= padding;
    }
    else {
        //Fix output for printing functions
        output[outputSize] = 0;
    }

    return output;
}

uint8_t * Aes::CryptData2(const char * data, size_t dataSize, const char * key, uint8_t * IV, size_t & outputSize) {
    //Setup
    Sanitize();
    uint8_t uToCrypt[16];
    uint8_t temp[16];

    memcpy(temp, IV, 16);
    outputSize = (dataSize / 16 + 1) * 16 ;
    uint8_t* output = new uint8_t[outputSize] ;
    memcpy(output, data, dataSize);
    memset(output + dataSize, outputSize - dataSize, outputSize - dataSize);

    //CBC chain crypt;
    for (size_t pos = 0; pos<outputSize; pos += 16) {
        memcpy(uToCrypt, output + pos, 16);

        //Crypt
        Sanitize();
        Crypt(uToCrypt, (uint8_t *)key, temp);
        memcpy(temp, uToCrypt, 16);

        //Copy data
        memcpy(&output[pos], uToCrypt, 16);
    }

    return output;
}

char * Aes::DecryptData2(uint8_t * data, size_t dataSize, const char * key, uint8_t * IV, size_t & outputSize) {
    //Setup
    Sanitize();
    uint8_t uToDecrypt[16];
    uint8_t temp[16];

    memcpy(temp, IV, 16);
    char* output = new char[dataSize];

    //Precompute key
    memset(expandedKey, 0, 16);
    PrecomputeDecryptKey((uint8_t*)key);

    //CBC chain Decrypt;
    for (size_t pos = 0; pos<dataSize; pos += 16) {
        memcpy(uToDecrypt, data + pos, 16);

        //Decrypt
        Sanitize();
        Decrypt(uToDecrypt, (uint8_t *)key, temp);
        memcpy(temp, data + pos, 16);

        //Copy data
        memcpy(&output[pos], uToDecrypt, 16);
    }

    outputSize = dataSize - output[dataSize - 1] ;
    output[outputSize] = 0;

    return output;
}
#endif


void* il2cpp::vm::MetadataLoader::LoadMetadataFile(const char* fileName)
{
	std::string resourcesDirectory = utils::PathUtils::Combine(utils::Runtime::GetDataDir(), utils::StringView<char>("Metadata"));

	std::string resourceFilePath = utils::PathUtils::Combine(resourcesDirectory, utils::StringView<char>(fileName, strlen(fileName)));

	int error = 0;
	os::FileHandle* handle = os::File::Open(resourceFilePath, kFileModeOpen, kFileAccessRead, kFileShareRead, kFileOptionsNone, &error);
	if (error != 0)
	{
		utils::Logging::Write("ERROR: Could not open %s", resourceFilePath.c_str());
		return NULL;
	}

	void* fileBuffer = utils::MemoryMappedFile::Map(handle);


	int64_t length = os::File::GetLength(handle, &error);





	os::File::Close(handle, &error);
	if (error != 0)
	{
		utils::MemoryMappedFile::Unmap(fileBuffer);
		fileBuffer = NULL;
		return NULL;
	}

	char key[] = "{Key}";
	char vector[] = "{Ivector}";

	Aes* aes = new Aes;
	size_t outputSize = 0;
	char* data=aes->DecryptData2((uint8_t*)fileBuffer,length,key, (uint8_t*)vector, outputSize);

	utils::MemoryMappedFile::Unmap(fileBuffer);
	fileBuffer = NULL;
    return (void*)data;
}
